# 任务六

## 6.1

ceres自动求导原理：

ceres自动求导是通过**前向求导**(由内到外的链式法则)实现的：函数值和函数值对所有变量的导数同时计算。在自变量上加上一个无穷小量e，其中 e≠0,e^2^=0，对函数进行一阶泰勒展开，求解出来的值就是对应的偏导数的值。



## 6.5

ceres中直接使用`double*`来指向四元数即可，使用`ceres::QuaternionRotatePoint(quantion, p, result )`函数，实现对点的四元数旋转。



对于四元数这种使用过参数化表示旋转的方式，它们是不支持广义的加法，所以我们在使用ceres对其进行迭代更新的时候就需要自定义其更新方式，需要自定义一个子类，继承于`LocalParameterization`。可以在继承的子类中定义四元数雅可比的加法迭代。

`LocalParameterization`是在优化 Manifold 上的变量时需要考虑的，Manifold 上变量是 over parameterized，即 Manifold 上变量的维度大于其自由度。这会导致 Manifold 上变量各个量之间存在约束，如果直接对这些量求导、优化，那么这就是一个有约束的优化，实现困难。为了解决这个问题，在数学上是对 Manifold 在当前变量值处形成的切空间（Tangent Space）求导，在切空间上优化，最后投影回 Manifold。

对于 SLAM 问题，广泛遇到的 Manifold 是旋转，旋转仅需使用 3 个量（so(3)）即可表达，但是实际应用中因为涉及到万向锁的问题，在更高维度表达旋转。四元数就是在维度 4 表达 3 个自由度的三维空间的旋转。

`ComputeJacobian` 计算得到的矩阵含义是 Manifold 上变量对 Tangent Space 上变量的导数。

`CostFunction` 处提供 residuals 对 Manifold 上变量的导数。

两者相乘就得到了residuals对Tangent Space上变量的导数，再进行迭代更新Tangent Space 上的变量，最后投影回Manifold 中